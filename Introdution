graph[i][j] = 1 or wt (matrix but not usefull because of space complexity) O(n^2)

graph[i].push_back(j); (list useful) O(v + e)

wity weight 
graph[i].push_back({j, wt});

-----------------------------------------------------------------------------------------

                            (DFS)

void dfs(ll vertex){
    // take action after enter into the vertex
    visited[vertex] = true;
    for(auto child : graph[vertex]){
        if(visited[child]){
            cotninue;
        }
        // take action before call the dfs for child
        dfs(child);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

O(N + E)

cycle detection and connected component

---------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        depth[child] = depth[vertex] + 1;
        dfs(child);
        height[vertex] = max(height[vertex], height[child] + 1);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    subtree_sum[vertex] += vertex;
    even_cnt[vertex] = (vertex % 2);
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        dfs(child);
        subtree_sum[vertex] += subtree_sum[child];
        even_cnt[vertex] += even_cnt[child];
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}
