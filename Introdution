graph[i][j] = 1 or wt (matrix but not usefull because of space complexity) O(n^2)

graph[i].push_back(j); (list useful) O(v + e)

wity weight 
graph[i].push_back({j, wt});

-----------------------------------------------------------------------------------------

                            (DFS)

void dfs(ll vertex){
    // take action after enter into the vertex
    visited[vertex] = true;
    for(auto child : graph[vertex]){
        if(visited[child]){
            cotninue;
        }
        // take action before call the dfs for child
        dfs(child);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

O(N + E)

cycle detection and connected component

---------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        depth[child] = depth[vertex] + 1;
        dfs(child);
        height[vertex] = max(height[vertex], height[child] + 1);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    subtree_sum[vertex] += vertex;
    even_cnt[vertex] = (vertex % 2);
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        dfs(child);
        subtree_sum[vertex] += subtree_sum[child];
        even_cnt[vertex] += even_cnt[child];
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------

To find diameter of tree is 
first stemp --> take any node of tree and run dfs
find max depth node;
and second stemp --> take that node and run dfs and max value is diameter.

------------------------------------------------------------------------------------

            (LCA)

run dfs and store parent of all node
take one node and call function path return path

compare min(both path) longest comman node is LCA.

par[vertex] = p;

-------------------------------------------------------------------------------

void bfs(int source){
    queue<int> Q;
    Q.push(source);
    while(!Q.empty()){
        auto i = Q.front();
        Q.pop();
        for(auto child : graph[i]){
            if(!visited[child]){
                Q.push(child);
                visited[child] = true;
                level[child] = level[i] + 1;
            }
        }
    }
}

O(v + e);
