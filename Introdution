graph[i][j] = 1 or wt (matrix but not usefull because of space complexity) O(n^2)

graph[i].push_back(j); (list useful) O(v + e)

wity weight 
graph[i].push_back({j, wt});

-----------------------------------------------------------------------------------------

                            (DFS)

void dfs(ll vertex){
    // take action after enter into the vertex
    visited[vertex] = true;
    for(auto child : graph[vertex]){
        if(visited[child]){
            cotninue;
        }
        // take action before call the dfs for child
        dfs(child);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

O(N + E)

cycle detection and connected component

---------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        depth[child] = depth[vertex] + 1;
        dfs(child);
        height[vertex] = max(height[vertex], height[child] + 1);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    subtree_sum[vertex] += vertex;
    even_cnt[vertex] = (vertex % 2);
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        dfs(child);
        subtree_sum[vertex] += subtree_sum[child];
        even_cnt[vertex] += even_cnt[child];
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------

To find diameter of tree is 
first stemp --> take any node of tree and run dfs
find max depth node;
and second stemp --> take that node and run dfs and max value is diameter.

------------------------------------------------------------------------------------

            (LCA)

run dfs and store parent of all node
take one node and call function path return path

compare min(both path) longest comman node is LCA.

par[vertex] = p;

-------------------------------------------------------------------------------

void bfs(int source){
    queue<int> Q;
    Q.push(source);
    while(!Q.empty()){
        auto i = Q.front();
        Q.pop();
        for(auto child : graph[i]){
            if(!visited[child]){
                Q.push(child);
                visited[child] = true;
                level[child] = level[i] + 1;
            }
        }
    }
}

O(v + e);

----------------------------------------------------------------------------

0-1 bfs
if edges weight is 0 then add to front of the queue
otherwise add back of the queue

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T = 1;
    // cin >> T;
    while(T--){
        int n, m; cin >> n >> m;
        vector<vector<pair<int, int>>> graph(n + 1);
        fori(i, 0, m){
            int u, v; cin >> u >> v;
            graph[u].pb({v, 0});
            graph[v].pb({u, 1});
        }
        vector<int> level(n + 1, INT_MAX);
        deque<int> Q;
        level[1] = 0;
        Q.push_back(1);
        while(!Q.empty()){
            auto i = Q.front();
            Q.pop_front();
            for(auto child : graph[i]){
                int a = child.first;
                int b = child.second;
                if(level[i] + b < level[a]){
                    level[a] = level[i] + b;
                    if(b){
                        Q.push_back(a);
                    }else{
                        Q.push_front(a);
                    }
                }
            }
        }
        level[n] == INT_MAX ? c(-1) : c(level[n]);
        sahil:; 
    }
    return 0;
}

------------------------------------------------------------------------

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T;
    cin >> T;
    while(T--){
        ll n, m; cin >> n >> m;
        vector<vector<ll>> v(n, vector<ll> (m));
        ll mx = -1;
        fori(i, 0, n){
            fori(j, 0, m){
                cin >> v[i][j];
                mx = max(mx, v[i][j]);
            }
        }
        queue<pair<ll, ll>> Q;
        vector<vector<ll>> level(n, vector<ll> (m, INT_MAX)); 
        fori(i, 0, n){
            fori(j, 0, m){
                if(v[i][j] == mx){
                    Q.push({i, j});
                    level[i][j] = 0;
                }
            }
        }
        vector<pair<ll, ll>> movement = {
            {0, -1}, {-1, 0}, {1, 0}, {0, 1},
            {1, 1}, {1, -1}, {-1, 1}, {-1, -1} 
        };
        ll ans = 0;
        while(!Q.empty()){
            auto i = Q.front();
            Q.pop();
            ll x = i.ff, y = i.ss;
            for(auto k : movement){
                ll xx = x + k.ff, yy = y + k.ss;
                if(xx >= 0 && xx < n && yy >= 0 && yy < m){
                    if(level[x][y] + 1 < level[xx][yy]){
                        Q.push({xx, yy});
                        level[xx][yy] = level[x][y] + 1;
                        ans = max(ans, level[xx][yy]);
                    }
                }
            }
        }
        cout << ans << endl;
        sahil:; 
    }
    return 0;
}

-----------------------------------------------------------------------------


