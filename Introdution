graph[i][j] = 1 or wt (matrix but not usefull because of space complexity) O(n^2)

graph[i].push_back(j); (list useful) O(v + e) O(2 * E) --> undirected , O(E) --> direceted

wity weight 
graph[i].push_back({j, wt});

-----------------------------------------------------------------------------------------

                            (DFS)

void dfs(ll vertex){
    // take action after enter into the vertex
    visited[vertex] = true;
    for(auto child : graph[vertex]){
        if(visited[child]){
            cotninue;
        }
        // take action before call the dfs for child
        dfs(child);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

O(N + E)

cycle detection and connected component

---------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        depth[child] = depth[vertex] + 1;
        dfs(child);
        height[vertex] = max(height[vertex], height[child] + 1);
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------------

void dfs(ll vertex, ll par = -1){
    // take action after enter into the vertex
    subtree_sum[vertex] += vertex;
    even_cnt[vertex] = (vertex % 2);
    for(auto child : graph[vertex]){
        // take action before call the dfs for child
        if(child == par){
            continue;
        }
        dfs(child);
        subtree_sum[vertex] += subtree_sum[child];
        even_cnt[vertex] += even_cnt[child];
        // take action after call the dfs for child
    }
    // take action after exit for the vertex
}

-------------------------------------------------------------------------------------

To find diameter of tree is 
first stemp --> take any node of tree and run dfs
find max depth node;
and second stemp --> take that node and run dfs and max value is diameter.

------------------------------------------------------------------------------------

            (LCA)

run dfs and store parent of all node
take one node and call function path return path

compare min(both path) longest comman node is LCA.

par[vertex] = p;

-------------------------------------------------------------------------------

void bfs(int source){
    queue<int> Q;
    Q.push(source);
    while(!Q.empty()){
        auto i = Q.front();
        Q.pop();
        for(auto child : graph[i]){
            if(!visited[child]){
                Q.push(child);
                visited[child] = true;
                level[child] = level[i] + 1;
            }
        }
    }
}

O(v + e);

----------------------------------------------------------------------------

0-1 bfs
if edges weight is 0 then add to front of the queue
otherwise add back of the queue

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T = 1;
    // cin >> T;
    while(T--){
        int n, m; cin >> n >> m;
        vector<vector<pair<int, int>>> graph(n + 1);
        fori(i, 0, m){
            int u, v; cin >> u >> v;
            graph[u].pb({v, 0});
            graph[v].pb({u, 1});
        }
        vector<int> level(n + 1, INT_MAX);
        deque<int> Q;
        level[1] = 0;
        Q.push_back(1);
        while(!Q.empty()){
            auto i = Q.front();
            Q.pop_front();
            for(auto child : graph[i]){
                int a = child.first;
                int b = child.second;
                if(level[i] + b < level[a]){
                    level[a] = level[i] + b;
                    if(b){
                        Q.push_back(a);
                    }else{
                        Q.push_front(a);
                    }
                }
            }
        }
        level[n] == INT_MAX ? c(-1) : c(level[n]);
        sahil:; 
    }
    return 0;
}

------------------------------------------------------------------------

                    (Multi-Source BFS)

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T;
    cin >> T;
    while(T--){
        ll n, m; cin >> n >> m;
        vector<vector<ll>> v(n, vector<ll> (m));
        ll mx = -1;
        fori(i, 0, n){
            fori(j, 0, m){
                cin >> v[i][j];
                mx = max(mx, v[i][j]);
            }
        }
        queue<pair<ll, ll>> Q;
        vector<vector<ll>> level(n, vector<ll> (m, INT_MAX)); 
        fori(i, 0, n){
            fori(j, 0, m){
                if(v[i][j] == mx){
                    Q.push({i, j});
                    level[i][j] = 0;
                }
            }
        }
        vector<pair<ll, ll>> movement = {
            {0, -1}, {-1, 0}, {1, 0}, {0, 1},
            {1, 1}, {1, -1}, {-1, 1}, {-1, -1} 
        };
        ll ans = 0;
        while(!Q.empty()){
            auto i = Q.front();
            Q.pop();
            ll x = i.ff, y = i.ss;
            for(auto k : movement){
                ll xx = x + k.ff, yy = y + k.ss;
                if(xx >= 0 && xx < n && yy >= 0 && yy < m){
                    if(level[x][y] + 1 < level[xx][yy]){
                        Q.push({xx, yy});
                        level[xx][yy] = level[x][y] + 1;
                        ans = max(ans, level[xx][yy]);
                    }
                }
            }
        }
        cout << ans << endl;
        sahil:; 
    }
    return 0;
}

-----------------------------------------------------------------------------

                            (Dijstra)
                            
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        int u = times.size(), v = times[0].size();
        vector<vector<pair<int, int>>> graph(n + 1);
        for(int i = 0; i < u; i++){
            graph[times[i][0]].push_back({times[i][1], times[i][2]});
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, k});
        vector<bool> visited(n + 1, false);
        vector<int> level(n + 1, INT_MAX);
        level[k] = 0;
        while(!Q.empty()){
            auto i = Q.top();
            Q.pop();
            int x = i.first, y = i.second;
            if(visited[y]){
                continue;
            }
            visited[y] = true;
            for(auto child : graph[y]){
                int xx = child.first;
                int yy = child.second;
                if(level[y] + yy < level[xx]){
                    level[xx] = level[y] + yy;
                    Q.push({level[xx], xx});
                }
            }
        }
        int ans = INT_MIN;
        for(int i = 1; i <= n; i++){
            ans = max(ans, level[i]);
        }
        return ans == INT_MAX ? -1 : ans;
    }
};

O(V + E(log(V)))

--------------------------------------------------------------------------------------------------

                              (Floyd Warshall)

vector<vector<ll>> dist(n, vector<ll> (n, INT_MAX));
    fori(i, 0, n){
        fori(j, 0, n){
            if(i == j){
                dist[i][j] = 0;
            }
        }
    }
    fori(i, 0, m){
        ll u, v, wt; cin >> u >> v >> wt;
        dist[u][v] = wt;
    }
    fori(via, 0, n){
        fori(i, 0, n){
            fori(j, 0, n){
                if(dist[i][via] != INT_MAX && dist[via][j] != INT_MAX){
                    dist[i][j] = min(dist[i][j], dist[i][via] + dist[via][j]);
                }
            }
        }
    }
    
-------------------------------------------------------------------------------------------------

                            (Kruskal's Algo) - Minimum spanning tree

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); 
    ll T = 1;
    // cin >> T;
    while(T--){
        ll n; cin >> n;
        dsu<ll> obj(n);
        vector<pair<ll, ll>> yam(n + 1);
        fori(i, 1, n + 1){
            cin >> yam[i].ff >> yam[i].ss;
        }
        // cp(yam);
        vector<ll> cost(n + 1);
        fori(i, 1, n + 1){
            cin >> cost[i];
        }
        vector<ll> dist(n + 1);
        fori(i, 1, n + 1){
            cin >> dist[i];
        }
        vector<pair<ll, pair<ll, ll>>> edges;
        fori(i, 1, n + 1){
            edges.pb({cost[i], {0, i}});
        }
        fori(i, 1, n + 1){
            fori(j, i + 1, n + 1){
                ll wire = abs(yam[i].ff - yam[j].ff) + abs(yam[i].ss - yam[j].ss);
                ll pdu = wire * (dist[i] + dist[j]);
                edges.pb({pdu , {i, j}});
            }
        }
        sort(all(edges));
        ll final = 0;
        vector<ll> power;
        vector<pair<ll, ll>> couple;
        for(auto i : edges){
            ll wt = i.ff;
            ll u = i.ss.ff;
            ll v = i.ss.ss;
            if(obj.getp(u) == obj.getp(v)){
                continue;
            }
            obj.merge(u, v);
            final += wt;
            if(u == 0){
                power.pb(v);
            }else{
                couple.pb({u, v});
            }
        }
        c(final); 
        c(sz(power)); cv(power); 
        c(sz(couple)); cp(couple);
        sahil:; 
    }
    return 0;
}
