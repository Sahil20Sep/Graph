ancestors --> parent, grandparent, ettc..

full binary tree -- > all node have 0 or 2 children

complete binary tree --> all level are completyly filled except the last level and in last level all node as left side as possible

perfect binary tree --> all leaf node has to be in same level

degenerate tree --> every node have signle children || starigh line

struct node
{
    int data;
    struct node *left;
    struct node *right;

    node (int val){
        data = val;
        left = right = NULL;
    }
};

struct node *root = new node(1);
root -> left = new node(2);
root -> right = new node(3);
root -> left -> right = new node(5);

(DFS)

inorder --> left root right

preorder --> root left right

postorder --> left right root

        1
    2      3
4    5   6     7

inorder --> 4 2 5 1 6 3 7

preorder --> 1 2 4 5 3 6 7

postorder --> 4 5 2 6 7 3 1

(BFS)

level wise

-----------------------------------------------------------

      (PRE ORDER TRAVESER)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void preorder(TreeNode* root, vector<int> &ans){
        if(root == NULL){
            return;
        }

        ans.push_back(root -> val);

        preorder(root -> left, ans);

        preorder(root -> right, ans);
    }

    vector<int> preorderTraversal(TreeNode* root) {

        if(root == NULL){
            return {};
        }

        vector<int> ans;

        // preorder(root, ans);

        stack<TreeNode*> st; 

        st.push(root);

        while(!st.empty()){
            root = st.top(); 
            st.pop();

            ans.push_back(root -> val);

            if(root -> right != NULL){
                st.push(root -> right);
            }

            if(root -> left != NULL){
                st.push(root -> left);
            }
        }

        return ans;

    }
};

TIME --> O(N) , SPACE --> O(N) or in itretive O(height)

-------------------------------------------------------------------

          (INORDER)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void inorder(TreeNode* root, vector<int> &ans){

        if(root == NULL){
            return ;
        }

        inorder(root -> left, ans);

        ans.push_back(root -> val);

        inorder(root -> right, ans);

    }

    vector<int> inorderTraversal(TreeNode* root) {
        
        vector<int> ans;

        // inorder(root, ans);

        stack<TreeNode*> st;

        auto node = root;

        while(1){
            if(node != NULL){
                st.push(node);
                node = node -> left;
            }else{
                if(st.empty()){
                    break;
                }
                node = st.top();
                st.pop();
                ans.push_back(node -> val);
                node = node -> right;
            }
        }

        return ans;
    }
};

------------------------------------------------------------------------

        (postorder)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void postorder(TreeNode* root, vector<int> &ans){

        if(root == NULL){
            return ;
        }

        postorder(root -> left, ans);

        postorder(root -> right, ans);

        ans.push_back(root -> val);

    }

    vector<int> postorderTraversal(TreeNode* root) {

        if(root == NULL){
            return {};
        }
        
        vector<int> ans;

        // postorder(root, ans);

        stack<TreeNode*> st;

        auto current = root;

        while(!st.empty() || current != NULL){
            if(current != NULL){

                st.push(current);

                current = current -> left;

            }else{

                auto temp = st.top() -> right;

                if(temp == NULL){

                    temp = st.top();
                    st.pop();
                    ans.push_back(temp -> val);

                    while(!st.empty() && temp == st.top() -> right){
                        temp = st.top();
                        st.pop();
                        ans.push_back(temp -> val);
                    }

                }else{

                    current = temp;

                }
            }
        }

        return ans;
    }
};

--------------------------------------------------------------------------------------------

              (BFS)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        if(root == NULL){
            return {};
        }
        
        vector<vector<int>> ans;

        vector<int> store;

        queue<TreeNode*> Q;

        Q.push(root);

        while(!Q.empty()){
            
            auto s = Q.size();

            while(s--){
                auto f = Q.front();
                Q.pop();
                store.push_back(f -> val);

                if(f -> left != NULL){
                    Q.push(f -> left);
                }
                
                if(f -> right != NULL){
                    Q.push(f -> right);
                }
            }

            ans.push_back(store);

            store.clear();

        }

        return ans;

    }
};

TIME --> O(N) , SPACE --> O(N)

--------------------------------------------------------------------------------------

